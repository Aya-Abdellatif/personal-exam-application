from typing import Iterable


class FPTreeNode:
    """
    represents the node in a FrequentPattern tree
    """

    def __init__(self, item) -> None:
        self.item = item
        self.count = 1
        self.children = {}
        self.parent = None

    def increment(self) -> None:
        """
        increments the counter by 1
        """
        self.count += 1


class FPTree:
    """
    represents the FrequentPattern Tree
    """

    def __init__(self):
        self.root = FPTreeNode(None)  # Root node
        self.header_table = {}

    def add_transaction(self, transaction: Iterable[str]) -> None:
        """
        adds a transaction to the FrequentPattern tree
        :param transaction: the transaction to add
        """
        current_node = self.root

        for item in transaction:
            if item in current_node.children:
                current_node.children[item].increment()
            else:
                new_node = FPTreeNode(item)
                new_node.parent = current_node
                current_node.children[item] = new_node

                # Update header table
                if item not in self.header_table:
                    self.header_table[item] = []
                self.header_table[item].append(new_node)

            current_node = current_node.children[item]


class FrequentPatternManager:
    """
    a class to manage the FrequentPattern tree with methods to build and mine the FrequentPattern tree
    """

    @staticmethod
    def build_fp_tree(sorted_transactions: Iterable[Iterable[str]]) -> FPTree:
        """
        builds a FrequentPattern tree from a list of transactions
        :param sorted_transactions:
        :return: a FrequentPattern tree
        """
        fp_tree = FPTree()
        for transaction in sorted_transactions:
            fp_tree.add_transaction(transaction)
        return fp_tree

    @staticmethod
    def mine_fp_tree(header_table, min_support=2, prefix=None):
        """
        mines a FrequentPattern tree from a list of transactions
        :param header_table: the header table
        :param min_support: the minimum support of the FrequentPattern tree
        :param prefix: the prefix of the FrequentPattern tree
        :return: frequent patterns (a list of tuples mapping topics to frequency)
        """
        if prefix is None:
            prefix = []

        frequent_itemsets = []
        for item, nodes in header_table.items():
            # Calculate the support for the item
            support = sum(node.count for node in nodes)
            if support >= min_support:
                new_prefix = prefix + [item]
                frequent_itemsets.append((new_prefix, support))

                # Build conditional pattern base
                conditional_pattern_base = []
                for node in nodes:
                    path = []
                    parent = node.parent
                    while parent and parent.item is not None:
                        path.append(parent.item)
                        parent = parent.parent
                    for _ in range(node.count):
                        conditional_pattern_base.append(path)

                # Build conditional FP-tree
                conditional_tree = FPTree()
                for transaction in conditional_pattern_base:
                    conditional_tree.add_transaction(transaction)

                # Recursively mine the conditional FP-tree
                frequent_itemsets += FrequentPatternManager.mine_fp_tree(
                    conditional_tree.header_table, min_support, new_prefix
                )

        return frequent_itemsets

    @staticmethod
    def filter_items_with_duplicates(frequent_itemsets: list[tuple[list[str], int]]):
        """
        Gets frequent itemsets without duplicates
        :param frequent_itemsets: a list containing tuples of the topics mapped to their frequency
        which represents the frequent itemsets generated by the FrequentPattern tree
        :return: the itemsets without duplicate values
        """
        return [
            (topics, count)
            for topics, count in frequent_itemsets
            if len(topics) == len(set(topics))
        ]
